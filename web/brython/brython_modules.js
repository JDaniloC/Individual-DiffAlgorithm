__BRYTHON__.VFS_timestamp = 1589228477402
__BRYTHON__.use_VFS = true
var scripts = {"$timestamp": 1589228477401, "browser": [".py", "", [], 1], "browser.aio": [".py", "from _aio import *\n\ndef _task(coro,Id,block):\n async def _task():\n  block[Id]=None\n  try :\n   block[Id]=await coro\n  except Exception as e:\n   block[Id]=e\n   \n  if not block[Id]:\n   del block[Id]\n return _task()\n \nasync def gather(*coros,rate=0):\n dones={}\n counts=0\n for c in coros:\n  run(_task(c,f'task{counts}',dones))\n  counts +=1\n while not all(dones.values()):\n  await sleep(rate)\n return dones\n", ["_aio"]], "_aio": [".js", "// Replacement for asyncio.\n//\n// CPython asyncio can't be implemented for Brython because it relies on\n// blocking function (eg run(), run_until_complete()), and such functions\n// can't be defined in Javascript. It also manages an event loop, and a\n// browser only has its own built-in event loop.\n//\n// This module exposes functions whose result can be \"await\"-ed inside\n// asynchrounous functions defined by \"async def\".\n\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\n\nvar responseType = {\n    \"text\": \"text\",\n    \"binary\": \"arraybuffer\",\n    \"dataURL\": \"arraybuffer\"\n}\n\nfunction handle_kwargs(kw, method){\n    var data,\n        cache = \"no-cache\",\n        format = \"text\",\n        headers = {},\n        timeout = {}\n    for(var key in kw.$string_dict){\n        if(key == \"data\"){\n            var params = kw.$string_dict[key][0]\n            if(typeof params == \"string\"){\n                data = params\n            }else{\n                if(params.__class__ !== _b_.dict){\n                    throw _b_.TypeError.$factory(\"wrong type for data, \" +\n                        \"expected dict or str, got \" + $B.class_name(params))\n                }\n                params = params.$string_dict\n                var items = []\n                for(var key in params){\n                    items.push(encodeURIComponent(key) + \"=\" +\n                               encodeURIComponent(params[key][0]))\n                }\n                data = items.join(\"&\")\n            }\n        }else if(key == \"headers\"){\n            headers = _b_.dict.$to_obj(kw)\n        }else if(key.startsWith(\"on\")){\n            var event = key.substr(2)\n            if(event == \"timeout\"){\n                timeout.func = kw.$string_dict[key][0]\n            }else{\n                ajax.bind(self, event, kw.$string_dict[key][0])\n            }\n        }else if(key == \"timeout\"){\n            timeout.seconds = kw.$string_dict[key][0]\n        }else if(key == \"cache\"){\n            cache = kw.$string_dict[key][0]\n        }else if(key == \"format\"){\n            format = kw.$string_dict[key][0]\n        }\n    }\n    if(method == \"post\"){\n        // For POST requests, set default header\n        if(! headers.hasOwnProperty(\"Content-type\")){\n            headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n        }\n        if(data && !headers.hasOwnProperty(\"Content-Length\")){\n            headers[\"Content-Length\"] = data.length\n        }\n    }\n    return {\n        body: data,\n        cache: cache,\n        format: format,\n        timeout: timeout,\n        headers: headers\n    }\n}\n\nfunction ajax(){\n    var $ = $B.args(\"ajax\", 2, {method: null, url: null},\n            [\"method\", \"url\"], arguments, {},\n            null, \"kw\"),\n        method = $.method.toUpperCase(),\n        url = $.url,\n        kw = $.kw\n    var args = handle_kwargs(kw, \"get\")\n    if(! args.cache){\n        url = \"?ts\" + (new Date()).getTime() + \"=0\"\n    }\n    if(args.body && method == \"GET\"){\n        url = url + (args.cache ? \"?\" : \"&\") + args.body\n    }\n    var func = function(){\n        return new Promise(function(resolve, reject){\n            var xhr = new XMLHttpRequest()\n            xhr.open(method, url, true)\n            for(key in args.headers){\n                xhr.setRequestHeader(key, args.headers[key])\n            }\n            xhr.format = args.format\n            xhr.responseType = responseType[args.format]\n            xhr.onreadystatechange = function(){\n                if(this.readyState == 4){\n                    this.__class__ = HTTPRequest\n                    resolve(this)\n                }\n            }\n            if(method == \"POST\" && args.body){\n                xhr.send(args.body)\n            }else{\n                xhr.send()\n            }\n        })\n    }\n    func.$infos = {\n        __name__: \"ajax_\" + method\n    }\n    return {\n        __class__: $B.coroutine,\n        $args: [url, args],\n        $func: func\n    }\n}\n\nfunction event(){\n    // event(element, *names) is a Promise on the events \"names\" happening on\n    // the element. This promise always resolves (never rejects) with the\n    // first triggered DOM event.\n    var $ = $B.args(\"event\", 1, {element: null},\n            [\"element\"], arguments, {}, \"names\", null),\n        element = $.element,\n        names = $.names\n    return new Promise(function(resolve){\n        var callbacks = []\n        names.forEach(function(name){\n            var callback = function(evt){\n                // When one of the handled events is triggered, all bindings\n                // are removed\n                callbacks.forEach(function(items){\n                    $B.DOMNode.unbind(element, items[0], items[1])\n                })\n                resolve($B.$DOMEvent(evt))\n            }\n            callbacks.push([name, callback])\n            $B.DOMNode.bind(element, name, callback)\n        })\n    })\n}\n\nvar HTTPRequest = $B.make_class(\"Request\")\n\nHTTPRequest.data = _b_.property.$factory(function(self){\n    if(self.format == \"binary\"){\n        var view = new Uint8Array(self.response)\n        return _b_.bytes.$factory(Array.from(view))\n    }else if(self.format == \"text\"){\n        return self.responseText\n    }else if(self.format == \"dataURL\"){\n        var base64String = btoa(String.fromCharCode.apply(null,\n            new Uint8Array(self.response)))\n        return \"data:\" + self.getResponseHeader(\"Content-Type\") +\n            \";base64,\" + base64String\n    }\n})\n\nHTTPRequest.response_headers = _b_.property.$factory(function(self){\n    var headers = self.getAllResponseHeaders()\n    if(headers === null){return _b_.None}\n    var res = _b_.dict.$factory()\n    if(headers.length > 0){\n        // Convert the header string into an array\n        // of individual headers\n        var lines = headers.trim().split(/[\\r\\n]+/)\n        // Create a map of header names to values\n        lines.forEach(function(line){\n          var parts = line.split(': ')\n          var header = parts.shift()\n          var value = parts.join(': ')\n          _b_.dict.$setitem(res, header, value)\n        })\n    }\n    return res\n})\n\nfunction get(){\n    return ajax.bind(null, \"GET\").apply(null, arguments)\n}\n\nfunction iscoroutine(f){\n    return f.__class__ === $B.coroutine\n}\n\nfunction iscoroutinefunction(f){\n    return (f.$infos.__code__.co_flags & 128) != 0\n}\n\nfunction post(){\n    return ajax.bind(null, \"POST\").apply(null, arguments)\n}\n\nfunction run(coro){\n    var handle_success = function(){\n            $B.leave_frame()\n        },\n        handle_error = function(ev){\n            console.log(\"handle error, ev\", ev)\n            var err_msg = \"Traceback (most recent call last):\\n\"\n            err_msg += $B.print_stack(ev.$stack)\n            if(ev.__class){\n                err_msg += \"\\n\" + ev.__class__.$infos.__name__ +\n                    ': ' + ev.args[0]\n            }\n            $B.builtins.print(err_msg)\n            throw ev\n        }\n\n    var $ = $B.args(\"run\", 3, {coro: null, onsuccess: null, onerror: null},\n            [\"coro\", \"onsuccess\", \"onerror\"], arguments,\n            {onsuccess: handle_success, onerror: handle_error},\n            null, null),\n        coro = $.coro,\n        onsuccess = $.onsuccess,\n        onerror = $.onerror\n\n    if(onerror !== handle_error){\n        function error_func(exc){\n            try{\n                onerror(exc)\n            }catch(err){\n                handle_error(err)\n            }\n        }\n    }else{\n        error_func = handle_error\n    }\n    // Add top frame a second time to get the correct frame when the async\n    // function exits\n    $B.frames_stack.push($B.last($B.frames_stack))\n    $B.coroutine.send(coro).then(onsuccess).catch(error_func)\n    return _b_.None\n}\n\nfunction sleep(seconds){\n    var func = function(){\n        return new Promise(resolve => setTimeout(\n            function(){resolve(_b_.None)}, 1000 * seconds))\n    }\n    func.$infos = {\n        __name__: \"sleep\"\n    }\n    return {\n        __class__: $B.coroutine,\n        $args: [seconds],\n        $func: func\n    }\n}\n\nreturn {\n    ajax: ajax,\n    event: event,\n    get: get,\n    iscoroutine: iscoroutine,\n    iscoroutinefunction: iscoroutinefunction,\n    post: post,\n    run: run,\n    sleep: sleep\n}\n\n})(__BRYTHON__)\n"], "scripts.patience": [".py", "class PatienceDiff:\n    def __init__(self, funcao):\n        self.divisoes = []\n        self.stacks = []\n        self.funcao = funcao\n\n    def sortMerge(self, lista):\n        valores = self.patienceSorting(lista)\n        stacks = self.stacks\n        resultado = stacks[-1][:]\n        proximo = valores[resultado[-1]]\n\n        for i in range(len(stacks) - 2, -1, -1):\n            lista = stacks[i]\n            indice = lista.index(proximo)\n            resultado += lista[indice:]\n            for i in range(indice):\n                j = len(resultado) - 1\n                while resultado[j] < lista[i]:\n                    j -= 1\n                resultado.insert(j + 1, lista[i])\n            proximo = valores[resultado[-1]]\n        resultado.reverse()\n        return resultado\n    \n    def sortMin(self, lista):\n        valores = self.patienceSorting(lista)\n        stacks = self.stacks\n        resultado = []\n        while stacks != []:\n            menor = stacks[0][-1]\n            j = 0\n            for i in range(1, len(stacks)):\n                if menor > stacks[i][-1]:\n                    menor = stacks[i][-1]\n                    j = i\n            resultado.append(menor)\n            if len(stacks[j]) == 1:\n                stacks.pop(j)\n            else:\n                stacks[j].pop(-1)\n        return resultado\n\n    def longestIncreasingSubsequence(self, ponteiros):\n        '''\n            Percorre as pilhas do patience sorting\n        e pega o LIS da mesma\n\n        lista - Lista de stacks\n        reuturn: Lista = [int, int, ...]\n        '''\n        valor = self.stacks[-1][-1]\n        resultado = [valor]\n        while valor > ponteiros[valor]:\n            valor = ponteiros[valor]\n            resultado.append(valor)\n        resultado.reverse()\n        return resultado\n\n    def patienceSorting(self, lista):\n        '''\n            Devolve um dicion\u00e1rio de ponteiros\n        lista - Lista de n\u00fameros\n\n        return: dict = {int:int}\n        '''\n        pilhas = [ [lista[0]] ]\n        ponteiros = { lista[0]:lista[0] }\n        for i in range(1, len(lista)):\n            ver, atual = False, lista[i]\n            for j in range(len(pilhas)):\n                if pilhas[j][-1] > atual:\n                    pilhas[j].append(atual)\n                    ponteiros[atual], ver = pilhas[j-1][-1], True\n                    break\n            if not ver:\n                ponteiros[atual] = pilhas[-1][-1]\n                pilhas.append([atual])\n        self.stacks = pilhas\n        return ponteiros\n\n    def devolveUnicos(self, primeiro, segundo):\n        '''\n            Devolve todas as frases que est\u00e3o em ambos os textos\n        de forma que aparecem apenas uma vez em cada.\n\n        primeiro - Lista de strings\n        segundo - Lista de strings\n\n        return: lista = [[indicesA], [indicesB]]\n        '''\n        unicos = {}\n\n        for i in range(len(primeiro)):\n            if primeiro[i] in unicos:\n                unicos[primeiro[i]][0] += 1\n            else:\n                unicos[primeiro[i]] = [1, 0, i, None]\n        \n        for i in range(len(segundo)):\n            if segundo[i] in unicos:\n                unicos[segundo[i]][1] += 1\n                unicos[segundo[i]][3] = i\n        \n        unicos = list(zip(*[x[2:] for x in unicos.values() if x[:2] == [1, 1]]))\n\n        return unicos\n\n    def devolveIndices(self, indicesA, indicesB):\n        # Longest Increasing Subsequence em B\n        # Valores relativos de B em A\n        lista = self.longestIncreasingSubsequence(self.patienceSorting(indicesB))\n        lista = [indicesA[indicesB.index(x)] for x in lista]\n\n        # Pega a maior sequ\u00eancia\n        sequencia = []\n        for i in lista:\n            verificador = False\n            for j in sequencia:\n                if i > j[0] and len(j) == 1 and j[0] + 1 == i:\n                    j.append(i)\n                    verificador = True\n                    break\n                elif i > j[0] and len(j) == 2 and j[1] + 1 == i:\n                    j[1] = i\n                    verificador = True\n                    break\n            if not verificador:\n                sequencia.append([i])\n        resultado = max(sequencia, key = lambda x: x[1] - x[0] if len(x) == 2 else -float(\"inf\"))\n        if len(resultado) == 1:\n            resultado += resultado\n        return list(resultado) + [indicesB[indicesA.index(x)] for x in resultado]\n\n    def diffAlgorithm(self, primeiro, segundo):\n        if primeiro == [] or segundo == []:\n            self.divisoes.append(\"!\")\n            return [\" - \" + x for x in primeiro] + [\" + \" + x for x in segundo]\n        unicos = self.devolveUnicos(primeiro, segundo)\n\n        if unicos != []:\n            indA, indB = unicos\n            if len(indA) == 1:\n                inicioA, inicioB = indA[0], indB[0]\n                finalA, finalB = inicioA, inicioB\n            else:\n                inicioA, finalA, inicioB, finalB = self.devolveIndices(indA, indB)\n            \n            self.divisoes.append((inicioA, inicioB, finalA, finalB))\n\n            anterior = self.diffAlgorithm(primeiro[:inicioA], segundo[:inicioB])\n            proximo = self.diffAlgorithm(primeiro[finalA+1:], segundo[finalB+1:])\n            \n            return anterior + self.funcao(primeiro[inicioA:finalA+1], segundo[inicioB:finalB+1]) + proximo\n        else:\n            self.divisoes.append(\"!\")\n            return self.funcao(primeiro, segundo)\n\n    def junta(self, primeiro, segundo, divs):\n        if divs[0] == \"!\":\n            divs.pop(0)\n            return primeiro, segundo, divs\n        \n        inicio = divs[0][:2]\n        final = [x + 1 for x in divs[0][2:]]\n        \n        *cima, divs = self.junta(primeiro[:inicio[0]], segundo[:inicio[1]], divs[1:])\n        *baixo, divs = self.junta(primeiro[final[0]:], segundo[final[1]:], divs) \n        \n        meioA = [\"<hr>\"] + primeiro[inicio[0]:final[0]] + [\"<hr>\"]\n        meioB = [\"<hr>\"] + segundo[inicio[1]:final[1]] + [\"<hr>\"]\n        return cima[0] + meioA + baixo[0], cima[1] + meioB + baixo[1], divs\n        ", []], "scripts": [".py", "", [], 1], "scripts.frontDiff": [".py", "from browser import document, bind, alert, window, aio\nfrom scripts.patience import PatienceDiff\nfrom scripts.functions import compararArquivos\n\ndiff = PatienceDiff(compararArquivos)\n\nnumLinhas = 0\nfirst = False\nsecond = False\n\ndef colocarTag(tag, **atributos):\n    novo = document.createElement(tag)\n    if \"classe\" in atributos: novo.classList.add(atributos.get(\"classe\"))\n    if \"identificador\" in atributos: novo.id = atributos.get(\"indentificador\")\n    if \"texto\" in atributos: novo.text = atributos.get(\"texto\")\n    document <= novo\n    return novo\n\ndef criaInput(identificador, funcao):\n    entrada = document.createElement(\"input\")\n    entrada.id = identificador\n    entrada.type = \"file\"\n    entrada.accept = \"text/plain\"\n    entrada.onchange = funcao\n    return entrada\n\ndef aumentaLinhas():\n    global numLinhas\n    for div in [linha1, linha2]:\n        div.innerHTML = \"\"\n        for linha in range(1, numLinhas + 1):\n            nova = document.createElement(\"p\")\n            nova.style.margin = 0\n            nova.innerHTML = str(linha)\n            div.appendChild(nova)\n\ndef abrirArquivo(event):\n    async def ler():\n        global numLinhas, first, second\n        resultado = await event.target.files[0].text()\n        resultado = resultado.split(\"\\n\")\n        if numLinhas < len(resultado):\n            numLinhas = len(resultado)\n            aumentaLinhas()\n        if event.target.id == \"primeiro\":\n            first = resultado\n            esquerda.innerHTML = \"<br>\".join(resultado)\n        else:\n            second = resultado\n            direita.innerHTML = \"<br>\".join(resultado)\n        \n    aio.run(ler())\n\ndef criaComClasse(tag, classe):\n    novo = document.createElement(tag)\n    novo.classList.add(classe)\n    return novo\n\ndef exibir(evt):\n    global numLinhas, first, second\n    if first and second:\n        resultado = diff.diffAlgorithm(first, second)\n        if numLinhas < len(resultado):\n            numLinhas = len(resultado)\n            aumentaLinhas()\n        direita.innerHTML = \"\"\n        for linha in resultado:\n            p = document.createElement(\"p\")\n            p.style.margin = 0\n            if linha[1] == \"+\":\n                p.style.backgroundColor = \"#e6ffed\"\n            elif linha[1] == \"-\":\n                p.style.backgroundColor = \"#ffeef0\"\n            elif linha[1] == \"M\":\n                linha = linha[3:]\n            p.innerHTML = linha\n            direita.appendChild(p)\n        mostrarDivisoes()\n    else: alert(\"Selecione os arquivos!\")\n\ndef colocaBr(lista, outra):\n    i, j, cont = 0, 0, 0\n    while i < len(lista):\n        if lista[i] == \"<hr>\":\n            while j < len(outra) and outra[j] != \"<hr>\":\n                if outra[j] != \"<br>\" and cont <= 0: \n                    lista.insert(i, \"<br>\")\n                    i +=1\n                j += 1\n                cont -= 1\n            j += 1\n            cont = -1\n        i += 1\n        cont += 1\n    \n    resultado = []\n    for i in lista:\n        resultado.append(i)\n        if i != \"<hr>\" and i != \"<br>\":\n            resultado.append(\"<br>\")\n    return resultado\n\ndef mostrarDivisoes():\n    global first, second\n    divs = diff.divisoes\n    resultado = diff.junta(first, second, divs)\n    primeiro = colocaBr(resultado[0], resultado[1])\n    segundo = colocaBr(resultado[1], resultado[0])\n    \n    divEsquerdo.innerHTML = \"\".join(primeiro)\n    divDireito.innerHTML = \"\".join(segundo)\n\nif __name__ == \"__main__\":\n    colocarTag(\"H1\", texto = \"Patience Sorting\")\n\n    seletor = colocarTag(\"div\", classe = \"seletor\")\n    seletor.appendChild(criaInput(\"primeiro\", abrirArquivo))\n    seletor.appendChild(document.createTextNode(\"\u2192\"))\n    seletor.appendChild(criaInput(\"segundo\", abrirArquivo))\n\n    computar = colocarTag(\"button\", texto = \"Computar\", classe=\"computar\")\n    computar.onclick = exibir\n\n    linha1 = criaComClasse(\"div\", \"linhas\")\n    linha2 = criaComClasse(\"div\", \"linhas\")\n    esquerda = criaComClasse(\"div\", \"esquerda\")\n    direita = criaComClasse(\"div\", \"direita\")\n\n    span = colocarTag(\"span\", classe=\"main\")\n    span.appendChild(linha1)\n    span.appendChild(esquerda)\n    span.appendChild(linha2)\n    span.appendChild(direita)\n\n    colocarTag(\"h2\", texto = \"Divis\u00f5es\")\n\n    divisoes = colocarTag(\"div\", classe=\"main\")\n    divEsquerdo = criaComClasse(\"div\", \"esquerda\")\n    divDireito = criaComClasse(\"div\", \"direita\")\n    divisoes.appendChild(divEsquerdo)\n    divisoes.appendChild(divDireito)\n\n    voltar = colocarTag(\"a\", texto = \"Voltar\")\n    voltar.href = \"../index.html\"", ["browser", "browser.aio", "scripts.patience.PatienceDiff", "browser.alert", "scripts.patience", "browser.bind", "browser.window", "scripts.functions", "browser.document", "scripts.functions.compararArquivos", "scripts"]], "scripts.functions": [".py", "def abrirArquivo(nome):\n    try:\n        with open(nome) as arquivo:\n            resultado = arquivo.readlines()\n    except:\n        resultado = []\n    finally:\n        return resultado\n\ndef maiorSequenciaComum(primeiro, segundo):\n    # Preenche a primeira coluna\n    resultado = [[0] for x in range(len(segundo) + 1)]\n    # Preenche a primeira linha\n    resultado[0] = [0 for x in range(len(primeiro) + 1)]\n\n    for i in range(1, len(segundo) + 1):\n        for j in range(1, len(primeiro) + 1):\n            if primeiro[j - 1] == segundo[i - 1]:\n                resultado[i].append(resultado[i - 1][j - 1] + 1)\n            else:\n                resultado[i].append(max(resultado[i - 1][j], resultado[i][j - 1]))\n            \n    return resultado\n\ndef interpretador(matriz, palavra, outra):\n    i, j = len(matriz) - 1, len(matriz[0]) - 1\n    resultado = []\n    prefixo = \" M \"\n    verificador = False\n    \n    while i != 0 or j != 0:\n        numero = matriz[i][j]\n\n        if i != 0 and numero == matriz[i - 1][j]:\n            if verificador: prefixo = \"\"\n            resultado.append(\" + \" + outra[i - 1])\n            i -= 1\n        elif j != 0 and numero == matriz[i][j - 1]: \n            if verificador: prefixo = \"\"\n            resultado.append(\" - \" + palavra[j - 1])\n            j -= 1\n        else:\n            resultado.append(prefixo + palavra[j - 1])\n            i, j = i - 1, j - 1\n            verificador = True\n\n    return resultado[::-1]\n\ndef compararArquivos(primeiro, segundo):\n    #primeiro = abrirArquivo(primeiro)\n    #segundo = abrirArquivo(segundo)\n    \n    matriz = maiorSequenciaComum(primeiro, segundo)\n    resultado = interpretador(matriz, primeiro, segundo)\n\n    return resultado\n", []]}
__BRYTHON__.update_VFS(scripts)